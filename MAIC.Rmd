---
title: "MAIC"
author: "Wu Gong"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    code_folding: hide
    toc_depth: 6
    lightbox: true
    gallery: false
    highlight: monochrome
    css: Wu.css
---


	
```{r setup, echo=FALSE, cache=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(rmdformats)
library(Wu)
opts_chunk$set(echo=TRUE
             , cache=FALSE
             , eval=TRUE
             , prompt=FALSE
             , results="asis"
             , tidy=FALSE
             , comment=NA
             , message=FALSE
             , warning=FALSE
             , out.width = '80%'
             , class.source='klippy'
               )
eval_fast <- TRUE
eval_slow <- FALSE
klippy::klippy(position = c('top', 'left')
             , tooltip_message = 'Click to copy'
             , tooltip_success = 'Done')
```




# [Back to Index](index.html)


# Simulate Data

 * Individual Patient Data
   + Age with mean 40, sd 10
   + Gender with 60% female
 * Aggregate Data
   + Age with mean 30
   + Gender with 50% female


```{r}
set.seed(20221130)
n <- 450
age <- rnorm(n = n, mean = 40, sd = 10)
gender <- sample(x = c(0, 1), size = n, replace = TRUE, prob = c(0.4, 0.6))

dt <- data.table(age, gender)

vars <- c("age", "gender")
factorVars <- c("gender")

tbl <- Wu::tbl1n(data = dt
    , vars = vars
    , factorVars = factorVars)

tbl %>% prt()

## sweep(dt, MARGIN = 1, STATS = 1000, FUN = "+")[1:5, ]


ipd <- data.table(
    age = age
  , gender = gender
)

agd <- data.table(
    age_mean = 30
  , age_sd = 8
  , gender_mean = 0.5
)

```

# The Objective Function

 * The objective function gives one single numeric value
 * It sums up all covariates (X) with weights (a1) where covariates are matching variables
 * After centralizing covariates (X) (subtracting the mean), the algorithm tries to find weights to minimise the objective function's value (toward zero)
 * Weights vector a1 has the number of coefficients same as the number of covariates
 * In MAIC setting, the covariates are those variables need to be matched
 
```{r}

## x1 <- data.frame(age = c(1, 1.1, 1.2), weight = c(2, 2.4, 2.8))
## x1 <- as.matrix(x1)
## a <- c(1, 2)
## x1 %*% a
## exp(x1)

objfn <- function(a1, X){
    sum(exp(X %*% a1))
}

```

# Gradient Function

 * It is the partial derivatives of the objective function against parameters (a1)

```{r}
gradfn <- function(a1, X){
    colSums(sweep(X, 1, exp(X %*% a1), "*"))
}

```


# Centralized Individual Data

 * It applies the method of moments, for the first-order moment, subtracting the mean; for the second-order moment, subtracting the mean of squared.

```{r}
ipd <- ipd[, age_squared := age ^ 2]
agd <- agd[, age_squared := age_mean ^ 2 + age_sd ^ 2
                 ][, age := age_mean
                   ][, gender := gender_mean]

Vars <- c("age", "age_squared", "gender")

ipd_centralized <- ipd[, ..Vars] - agd[rep(1, nrow(ipd)), ..Vars]

## X.EM.0 <- sweep(with(AB.IPD, cbind(age
##                                  , age^2
##                                  , gender))
##               , 2
##               , with(AC.AgD, c(age.mean
##                              , age.mean^2 + age.sd^2
##                              , gender.mean))
##               , '-')

```


# Optimize the Weights

```{r}

opt1 <- optim(par = c(0, 0, 0)
            , fn = objfn
            , gr = gradfn
            , X = as.matrix(ipd_centralized)
            , method = "BFGS")

a1 <- opt1$par

wt <- exp(as.matrix(ipd_centralized) %*% a1)
wt_std <- (wt / sum(wt)) * n

ipd$wts <- wt_std

plt_hist(wt_std, xmin = 0, xmax = 10, xint = 0.2)



```

# Effective Sample Size

 * Kish's method
 
 $$Effective \, Sample \, Size = [\sum \omega_i]^2/[\sum \omega_i^2]$$

```{r}

sample_size <- data.table(
    n_original = nrow(ipd)
    , n_effective_sample_size = (sum(wt_std)) ^ 2 / sum(wt_std ^ 2)
)

sample_size %>% prt()




```

# Balance Table

```{r}
prs_agd <- agd[, c("age_mean", "age_sd", "gender")]

wmean <- function(x, wt){sum(x * wt) / sum(wt)}
wsd <- function(x, wt){
    wm <- wmean(x, wt)
    n <- length(x)
    sqrt( sum(wt * (x - wm) ^ 2)/ (sum(wt) * (n - 1) / n))
}


parameters_ipd <- c(
    age_mean = mean(ipd$age)
  , age_sd = sd(ipd$age)
  , gender_mean = mean(ipd$gender)
)


parameters_ipd_weighted <- c(
    age_mean = wmean(ipd$age, ipd$wts)
  , age_sd = wsd(ipd$age, ipd$wts)
  , gender_mean = wmean(ipd$gender, ipd$wts)
)


bt <- data.table(
    moment = names(prs_agd)
  , aggregate = as.numeric(prs_agd[1, ])
  , ipd = parameters_ipd
  , ipd_weighted = parameters_ipd_weighted
)

bt <- bt[, diff := ipd - aggregate
         ][, diff_weighted := ipd_weighted - aggregate]


bt[, .(moment, aggregate, ipd, diff, ipd_weighted, diff_weighted)] %>% prt()

```


# References


 * NICE MAIC: https://www.sheffield.ac.uk/nice-dsu/tsds/population-adjusted
 
 * R "maic" Package: https://cran.r-project.org/web/packages/maic/maic.pdf
 
 
# R sessionInfo

```{r}
sessionInfo()

```
