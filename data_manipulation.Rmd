---
title: "R Data Manipulation with data.table"
author: "Wu Gong"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    self_contained: true
    thumbnails: false
    code_folding: hide
    toc_depth: 6
    lightbox: true
    gallery: false
    highlight: monochrome
    css: Wu.css
---


```{r setup, echo=FALSE, cache=FALSE,warning=FALSE,message=FALSE}
library(knitr)
library(rmdformats)
library(Wu)
opts_chunk$set(echo=TRUE,
               cache=FALSE,
               eval=TRUE,
               prompt=FALSE,
               results="asis",
               tidy=FALSE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               out.width = '80%')
eval_fast <- TRUE
eval_slow <- FALSE
```

# [Back to Index](index.html)


# Read Data

## Pull Data from REDCap

 * Pull data from REDCap using API and save the csv file

```{r,eval=FALSE,echo=TRUE}

api_token       <- '1245456abcdef'
api_url         <- 'https://redcap_url/api/'
csv_file <- RCurl::postForm(
  api_url
  , token=api_token
  , content='record'
  , format='csv'
  , type='flat'
  , .opts=curlOptions(ssl.verifypeer=FALSE)
)
write(csv_file, file='../csv/filename.csv')

```

## Read Data from SAS/SPSS


```{r, eval=FALSE, echo=TRUE}
library(foreign)
## dt <- read.spss("filename",to.data.frame = TRUE)
library(haven)
## dt <- read_sas(data_file = "filename")
```

# General Data Description

 * Create a HTML file the describe all variables in a dataset

```{r, eval=FALSE,echo=TRUE}
Wu::sv_desc(dt, file_name = "dt_variables.html")

```

# Rename Variables & Revalue A Vector

 * match function matches the first vector to the second vector, gives the indexes of elements from vector one that matched in vector two
 * dplyr::rename function renames variable names

```{r}
library(Wu)

match(1:5, c(4, 2)) %>% prt()

dt <- data.table(A=1:3, B=2:4)
colnames(dt) %>% prt(caption = "Original Column Names")
colnames(dt) <- plyr::revalue(colnames(dt), c("A"="Variable_A"))
colnames(dt) %>% prt(caption = "Column Names Changed")


## dplyr::rename(dt, var_b=B)


lst <- list("A"="Variable_A")
## names(lst)
## unlist(lst)

colnames(dt)[colnames(dt) %in% names(lst)] <- unlist(lst)[colnames(dt)[colnames(dt) %in% names(lst)]]



v <- c("A", "B", "C")
lst <- c(
    "A"="A-"
  , "B"
  , "C"="C+"
)

plyr::revalue(v, lst) %>% prt(caption = "plyr::revalue function")

## names(lst)

v[v %in% names(lst)] <- unlist(lst)[v[v %in% names(lst)]]

v %>% prt()

## class(v)

dt <- data.table(var1 = 1, var2 = 2, var3 = 3)
Wu::renameVariables(obj = dt, lst = c(var1 = "varA", var2 = "varB")) %>% prt()


```

# Regular Expression

## Find Pattern

```{r}
grepl("High", c(NA, "High", "Low"), fixed=FALSE)

```

# Fill Missing Values


## Replace elements in a vector by a specific value


```{r}
x <- 1:10
list <- c(2, 4, 9)
value <- 0

replace(x, list, value)

```

## Index of observations

```{r}

dt <- data.table(
    group=c("A", "A", "B", "B", "B", "C", "C", "C", "C")
  , var1=1:9
)

dt <- dt[, index_i := .I
         ][, index_n := 1:.N
           ][, index_i_group := .I, by = .(group)
             ][, index_n_group := 1:.N, by = .(group)]

dt %>% prt()

```



## Last Observation Carry Forward (LOCF)

* data.table::nafill funtion only works for numeric variables
* Workaround for character variables by filling indexes of character variables instead <https://github.com/Rdatatable/data.table/issues/3992#issuecomment-546295277>
* type="nocb": Next Observation Carry Backward
* type="const": fill with constant

```{r}
dt <- data.table(
    n1=c(1, NA, 2, NA, NA, 3, 3, NA)
  , c1=c("A", "A", "B", NA, "C", NA, NA, NA)
)


dt <- dt[
  , n1_locf := nafill(n1, type="locf")
][, c1_locf := c1[nafill(replace(.I, is.na(c1), NA), type="locf")]
  ][, index := .I]

dt[, .(index, n1, n1_locf, c1, c1_locf)] %>% prt()
```

* More detailed process for character variables

```{r,eval=FALSE}
fdt2 <- fdt2[, i := .I
             ][is.na(state_daily4), i := NA
               ][, i_fill := nafill(i, type="locf"), by = .(record_id)
               ][, state_daily4_locf := state_daily4[i_fill]]

```




# Data Functions
## Sum Multiple Columns


```{r,eval=FALSE}

is.1 <- function(x){x %in% c(1)}
sum.1 <- function(x){sum(as.numeric(is.1(x)))}
dm <- dm[, race_sum := sum(.SD)
       , .SDcols = paste0("race___", as.character(1:6))
       , by = 1:nrow(dm)]
dm <- dm[, conditions_num := sum(is.1(hypertension)
                               , is.1(diabetes)
                               , is.1(heart_disease)
                               , is.1(renal_disease)
                               , is.1(malignancies)
                               , is.1(respiratory_disease)
                                 )
       , by = 1:nrow(dm)
         ]

```


## Rolling Average

```{r}
library(zoo)
dt <- data.table(series = c(1:10, NA, 11:21))
dt <- dt[, mv2 := rollmean(series, k = 2, align = "right", na.pad = TRUE)
         ][, mv3 := rollmean(series, k = 3, align = "right", na.pad = TRUE)]

dt %>% prt()

```

## Concatenate Multiple Rows by Group

```{r}

dt <- data.table(a=letters[1:10],b=LETTERS[1:10],ID=c(1,1,1,2,2,2,2,3,3,3))

dt

dt[, lapply(.SD, paste0, collapse=" "), by = ID, .SD = c("a")]

dt[, a2 := paste0(a, collapse = "-"), by = ID]


```

## Shift Column

```{r, eval=FALSE}
cf <- cf[
][, status_row_n_int := nafill(status_row_n, type = "locf"), by = list(mrn)
  ][, fio2_int := nafill(fio2_row_filled, type = "locf"), by = list(mrn)
    ][,  datetime_record_nx1 := shift(datetime_record, type="lead"), by = list(mrn)
      ][, time_int := as.numeric(difftime(datetime_record_nx1, datetime_record, units = "hours"))
        ]

```

## Permutate & combination

```{r,eval=FALSE}
expand.grid(levels(dt$sex_2.factor)
               , levels(dt$age_group)
               , levels(dt$race_ethnicity)
               , levels(dt$com_obesity)
                 )

combn(letters[1:4], 2)

perm_without_replacement <- function(n, r){
  return(factorial(n)/factorial(n - r)/ factorial(r))
}

factorial(4)
# 9 choose 3
perm_without_replacement(9, 3) * perm_without_replacement(6, 3)

6 * 5 * 4 / (3 * 2)

```
## Split data.frame

```{r,eval=FALSE}
split(t, seq(nrow(t)))

split(df, df$gender)

```


## Replicate Rows

```{r}
library(data.table)
library(Wu)
dt <- data.table(name=letters[1:4])
dt %>% prt()

dt <- dt[rep(1:.N, 3)][order(name)][, index := 1:.N, by = name]
dt %>% prt()

dt <- data.table(
    id = 1:6
  , num = c(3, 5, 6, 3, 4, 5)
)
dt <- dt[rep(1:.N, times = num)][, sub_index := 1:.N, by = id]
dt %>% prt()

```
# Generate Random Variables

 * Vectorize function
 * Generate random variables within data.table using values from another column
 
```{r}
library(Wu)
library(data.table)

dt <- data.table(
    id = 1:6
  , m = c(1:6)
)

rnorm_vec <- function(x){
    rnorm(n = 1, mean = x)
}
rnorm_vec <- Vectorize(rnorm_vec)

dt <- dt[, value := rnorm_vec(m)]

dt %>% prt()

```
## Pass Column Name to data.table within Function

```{r}
library(data.table)
dt <- data.table(var1=1:10, var2=rep(LETTERS[1:5], each=2))
knitr::kable(dt)

varName <- "var2"



knitr::kable(dt[, ..varName])

knitr::kable(dt[, varName, with = FALSE])

knitr::kable(dt[, .N, by = .(get(varName))])

knitr::kable(dt[, (varName) := paste0(get(varName), "+")])






pass_col <- function(clname){
    ## clname <- sym(clname)
    print(dt[, .N, by = clname])
}

pass_col(c("var1", "var2"))


```
# Reshape

## Reshape Wide to Long

```{r}
dt <- data.table(
    id=1:5
  , var_1=10:15
  , var_2=21:25
  , var_3=31:35
)

dt %>% prt()

vars <- paste0("var_", 1:3)

dtw <- melt(dt, id.vars="id", measure.vars = vars)

dtw %>% prt()

```

## Reshape Long to Wide


```{r}

t <- data.table(
  id = rep(c("A", "B"), each = 3)
, day = rep(1:3, 2)
, value = 1:6
)


t %>% prt()

tw <- dcast(t, id ~ day, value.var = "value")
class(tw)

tw %>% prt()



```


# Merge Multiple Tables

```{r, eval=FALSE}

t1 <- data.table(id = 1:10, var1 = rnorm(10, 1))
t2 <- data.table(id = 1:10, var2 = rnorm(10, 10))
t3 <- data.table(id = 1:10, var3 = rnorm(10, 100))
t4 <- data.table(id = 1:10, var4 = rnorm(10, 1000))

setkey(t1, id)
setkey(t2, id)
setkey(t3, id)
setkey(t4, id)

t <- Reduce(function(...) merge(..., all = TRUE)
            , list(t1, t2, t3, t4))

t %>% prt(caption = "Merge Multiple Tables by Key")

```
# Date and Time

## General

```{r,eval=FALSE}

as.POSIXct(
    data$guidewire_datetime
  , format='%Y-%m-%d %H:%M'
  , tz='GMT')

as.Date(data$diag_ecg_date_time, format='%Y-%m-%d')

get_datetime <- function(text){
    as.POSIXct(
        trimws(text)
      , format = "%Y-%m-%d %H:%M"
      , tz = "GMT"
      , origin = '1970-01-01'
    )
}

get_ed_arrival <- function(text){
    as.POSIXct(
        trimws(text)
      , format = "%m/%d/%y %H%M"
      , tz = "GMT"
      , origin = '1970-01-01'
    )
}

tf <- tf[
  , datetime_ed_arrival := get_ed_arrival(ed_arrival_time_str)
][, year_ed_arrival := format(datetime_ed_arrival, "%Y")
  ][, month_ed_arrival := format(datetime_ed_arrival, "%m")
  ][, yearmonth_ed_arrival := format(datetime_ed_arrival, "%Y%m")
    ][, weekdays_ed_arrival := weekdays(datetime_ed_arrival)
      ][, weekdays_ed_arrival := factor(
              weekdays_ed_arrival
            , levels = c(
                  "Sunday"
                , "Monday"
                , "Tuesday"
                , "Wednesday"
                , "Thursday"
                , "Friday"
                , "Saturday"
              )
          )
        ][, weekdays_ed_arrival_n := as.numeric(weekdays_ed_arrival)
          ][, hour_ed_arrival := data.table::hour(datetime_ed_arrival)
          ][, minute_ed_arrival := data.table::minute(datetime_ed_arrival)
            ][, hour_ed_arrival_c := strftime(datetime_ed_arrival, format = "%H", tz = "GMT")
              ][, minute_ed_arrival_c := strftime(datetime_ed_arrival, format = "%M", tz = "GMT")][, hour_ed_arrival_n := hour_ed_arrival + minute_ed_arrival/60]


tf <- tf[, flag_bussiness_hours := case_when(
               is.na(hour_ed_arrival) ~ as.character(NA)
             , hour_ed_arrival < 8 ~ "Non-Business Hours"
             , hour_ed_arrival == 17 & minute_ed_arrival >= 1 ~ "Non-Business Hours"
             , hour_ed_arrival > 17 ~ "Non-Business Hours"
             , TRUE ~ "Business Hours"
           )
         ][, flag_bussiness_hours := factor(
                 flag_bussiness_hours
               , levels = c("Business Hours", "Non-Business Hours")
             )]

tf <- tf[
  , flag_weekday := case_when(
        weekdays_ed_arrival %in% c("Tuesday", "Wednesday", "Thursday") ~ "Weekday"
      , weekdays_ed_arrival %in% c("Saturday", "Sunday") ~ "Weekend"
      , weekdays_ed_arrival %in% c("Friday") & hour_ed_arrival == 17 & minute_ed_arrival >= 1  ~ "Weekend"
      , weekdays_ed_arrival %in% c("Friday") & hour_ed_arrival > 17  ~ "Weekend"
      , weekdays_ed_arrival %in% c("Friday") ~ "Weekday"
      , weekdays_ed_arrival %in% c("Monday") & hour_ed_arrival == 7 & minute_ed_arrival <= 59 ~ "Weekend"
      , weekdays_ed_arrival %in% c("Monday") & hour_ed_arrival < 7 ~ "Weekend"
      , weekdays_ed_arrival %in% c("Monday") ~ "Weekday"
      , TRUE ~ as.character(NA)
    )
][, flag_weekday := factor(flag_weekday, levels = c("Weekday", "Weekend"))
  ][]


fp <- fp[
    , datetime_proc_start := get_datetime(proc_start_time_str)
][, year_proc_start := format(datetime_proc_start, "%Y")
  ][, yearmonth_proc_start := format(datetime_proc_start, "%Y%m")]


vs4 <- vs4[
  , ed_arrival_to_pas_discharge := as.numeric(difftime(
        datetime_pas_discharge
      , datetime_ed_arrival
      , units = "hours"
    ))
]

vs4 <- vs4[
    , date_ed_arrival := date(datetime_ed_arrival)
][, age_in_years := as.numeric(date_ed_arrival - dob)/365.25
  ][, age_group := case_when(
          age_in_years < 18 ~ "< 18"
        , age_in_years < 65 ~ "18-64"
        , age_in_years >= 65 ~ "65 +"
        , TRUE ~ as.character(NA)
      )
    ]


```


## Sequential Date

```{r}
sq <- seq.Date(from = as.Date('2019-07-01')
       , to = as.Date('2019-07-10')
       , by = 'days'
         )
print(sq)

sqt <- paste0(as.character(sq), " 00:00:00")
print(sqt)

sqt <- as.POSIXct(sqt, "%Y-%m-%d %H:%M:%S")
class(sqt)
print(sqt)
hour(sqt)

```


# Scale/One-hot encoding/Dummy Variable

## Scale and Unscale

```{r}
unscale <- function(x){
    x * attr(x, "scaled:scale") + attr(x, "scaled:center")
}

v <- c(1:10, NA)
vs <- scale(v)
vs2 <- (v - mean(v)) / sd(v)
v2 <- unscale(vs)
print(cbind(v, vs, vs2, v2))
str(vs)
attr(vs, "scaled:center")
attr(vs, "scaled:scale")

```

## One-Hot Encoding




### Wu::one_hot

 * Single impute numeric variables as median and add a column indicating missing values
 * Add NA level to categorical variables

```{r}

library(Wu)
set.seed(1234)
t <- data.table(var1=factor(sample(c("A", "B", "C", NA), 10, replace=TRUE), levels=c("A", "B", "C"))
              , var2=sample(c(1:10, rep(NA, 5)), 10)
              , var3=factor(rep(c("Red", "Green"), each=5), levels=c("Red", "Green", "Yellow"))
                )
t %>% prt()


ti <- Wu::one_hot(t
                , vars_numeric = c("var2")
                , vars_factor = c("var1", "var3")
                  )

ti %>% prt()



```


### mltools::one_hot

 * Only work on factors, not characters;
 * DEFAULT = "auto" encodes all unordered factor columns

```{r}
library(data.table)
t <- data.table(var1=factor(sample(c("A", "B", "C", NA), 10, replace=TRUE), levels=c("A", "B", "C"))
              , var2=1:10
                , var3=factor(rep(c("Red", "Green"), each=5), levels=c("Red", "Green", "Yellow"))
                )
print(t)
mltools::one_hot(t)
mltools::one_hot(t, sparsifyNAs = TRUE, naCols = TRUE)
mltools::one_hot(t, sparsifyNAs = TRUE, naCols = TRUE, dropCols = FALSE)
mltools::one_hot(t, sparsifyNAs = TRUE, naCols = TRUE, dropCols = FALSE, dropUnusedLevels=TRUE)


```

### caret::dummyVars

 * It converts all factor and character variables
 * fullRank remove referral level
 * Cannot drop unused levels

```{r}
library(caret)

set.seed(1234)
t <- data.table(var1=factor(sample(c("A", "B", "C", NA), 10, replace=TRUE), levels=c("A", "B", "C"))
              , var2=1:10
              , var3=factor(rep(c("Red", "Green"), each=5), levels=c("Red", "Green", "Yellow"))
              , var4=rep(c("Low", "High"), 5)
                )

t %>% prt()

dummy <- dummyVars(" ~ .", data=t, fullRank = TRUE)
tdummy <- data.frame(predict(dummy, t))

tdummy %>% prt()



```

## model.matrix

```{r}
model.matrix(~0 + ., t)

```

# Missing Values

 * Hot Deck method: a missing value was imputed from a randomly selected from similar record. Cards that are "hot" is currently being processed. Last observation carried forward (LOCF) is a kind of hot-desk imputation.
 * Cold-deck: impute data from donors from another dataset.
 * pmm: predictive mean matching


## mice package

```{r}
library(mice)
data <- airquality
data[4:10,3] <- rep(NA,7)
data[1:5,4] <- NA

data %>% prt()

md.pattern(data, plot=FALSE)

md.pattern(data)



```

## Multiple-Imputation

```{r}

library(mice)
set.seed(1234)
t <- data.table(id=1:10
              , var1=factor(sample(c("A", "B", "C", NA), 10, replace=TRUE), levels=c("A", "B", "C"))
              , var2=sample(c(1:10, rep(NA, 5)), 10, replace = TRUE)
              , var3=factor(rep(c("Red", "Green"), each=5), levels=c("Red", "Green", "Yellow"))
              , var4=rep(c("Low", "High"), 5)
                )

t %>% prt()

ti <- mice(t
         , m=5
         , maxit = 50
         , method = 'pmm'
         , seed = 500
         , printFlag = FALSE
           )

tic <- complete(ti, action = "all", include = TRUE)
##tic <- complete(ti, action = 2L, include = TRUE)


tic[[2]] %>% prt()

```


## VIM package

```{r}
library(VIM)
t <- data.table(id=1:10
                , var1=factor(sample(c("A", "B", "C", NA), 10, replace=TRUE), levels=c("A", "B", "C"))
              , var2=sample(c(1:10, NA), 10, replace = TRUE)
              , var3=factor(rep(c("Red", "Green"), each=5), levels=c("Red", "Green", "Yellow"))
              , var4=rep(c("Low", "High"), 5)
                )

matrixplot(t, sortby = c('id'))

```

# Computing Environment


```{r}
sessionInfo()
```
